import './conversationalsearchresult.scss';
import handlebars from 'handlebars';
import { marked } from 'marked';
import { validateContainer } from '../../util/dom';
import { observeStoreByKey } from '../../store';
import PRECOMPILED_CONVERSATIONAL_SEARCH_RESULT_TEMPLATE from './precompile-templates/conversationalsearchresult.handlebars';
import { registerHelper } from '../../util/handlebars';

export default class ConversationalSearchResult {
  constructor(client, reduxStore, conf) {
    this.client = client;
    this.conf = conf;
    this.reduxStore = reduxStore;
    this.answerMaxHeight = conf.answerMaxHeight || 150;
    this.isSearchResultLoading = false;
    this.observeResultLoadingState();

    registerHelper('markdown', function (text) {
      if (typeof text !== 'string') {
        return '';
      }

      return new handlebars.SafeString(marked.parse(text, { breaks: true, gfm: true }));
    });

    if (validateContainer(conf.containerId)) {
      observeStoreByKey(this.reduxStore, 'search', () => this.render());
    }
  }

  observeResultLoadingState() {
    this.reduxStore.subscribe(() => {
      const isConversationalSearchResultLoading =
        this.reduxStore.getState().search.loadingConversationalSearchResult;

      console.log(
        'observing state change for isConversationalSearchResultLoading',
        isConversationalSearchResultLoading
      );

      if (this.isLoading !== isConversationalSearchResultLoading) {
        this.isLoading = isConversationalSearchResultLoading;
        this.render();
      }
    });
  }

  setupShowMoreButton() {
    const answerContainer = document.querySelector('.answer-container');
    const fadeOutOverlay = answerContainer.querySelector('.fade-out-overlay');
    const showMoreBtn = document.querySelector('.show-more-btn');
    const buttonText = showMoreBtn.querySelector('.button-text');
    const chevron = showMoreBtn.querySelector('.chevron');

    if (answerContainer && showMoreBtn) {
      answerContainer.style.maxHeight = `${this.answerMaxHeight}px`;

      if (answerContainer.scrollHeight > this.answerMaxHeight) {
        showMoreBtn.style.display = 'flex';
        fadeOutOverlay.style.display = 'block';
      } else {
        showMoreBtn.style.display = 'none';
        fadeOutOverlay.style.display = 'none';
      }

      showMoreBtn.addEventListener('click', () => {
        if (answerContainer.classList.contains('collapsed')) {
          answerContainer.style.maxHeight = `${answerContainer.scrollHeight}px`;
          answerContainer.classList.remove('collapsed');
          buttonText.textContent = 'Show less';
          fadeOutOverlay.style.display = 'none';
        } else {
          answerContainer.style.maxHeight = `${this.answerMaxHeight}px`;
          answerContainer.classList.add('collapsed');
          buttonText.textContent = 'Show more';
          fadeOutOverlay.style.display = 'block';
          chevron.style.transform = 'rotate(180deg)';
        }
      });
    }
  }

  render() {
    const currentSearchState = this.reduxStore.getState().search;
    const currentConversationalSearchResult = currentSearchState.conversationalSearchResult;
    const currentlyLoadingConversationSearchResult =
      currentSearchState.loadingConversationalSearchResult;
    const keyword = currentSearchState.keyword;

    const handlebarTemplateProps = {
      mainHeadlineText: this.conf.mainHeadlineText || 'Answer',
      subHeadlineText: keyword,
      answerText: currentConversationalSearchResult.answerText,
      sourcesHeadlineText: this.conf.sourcesHeadlineText || 'Sources:',
      sources: currentConversationalSearchResult.sources,
      aiExplanationText: this.conf.aiExplanationText || 'Generated by AI, may contain errors.',
      isResultLoading: this.isLoading
    };

    // Compile HTML and inject to element if changed
    let html;

    if (
      currentConversationalSearchResult.answerText ||
      (keyword && currentlyLoadingConversationSearchResult)
    ) {
      if (this.conf.precompiledTemplate) {
        html = this.conf.precompiledTemplate(handlebarTemplateProps);
      } else if (this.conf.template) {
        html = handlebars.compile(this.conf.template)(handlebarTemplateProps);
      } else {
        html = PRECOMPILED_CONVERSATIONAL_SEARCH_RESULT_TEMPLATE(handlebarTemplateProps);
      }
    }

    if (this.renderedHtml === html) {
      return;
    }

    const container = document.getElementById(this.conf.containerId);
    container.innerHTML = html;
    this.renderedHtml = html;

    this.setupShowMoreButton();

    // Execute callback for when rendering is complete (if configured)
    if (
      this.conf.renderCompleteCallback &&
      typeof this.conf.renderCompleteCallback === 'function'
    ) {
      this.conf.renderCompleteCallback();
    }
  }
}
