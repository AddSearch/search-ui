import './conversationalsearchresult.scss';
import handlebars from 'handlebars';
import { marked } from 'marked';
import { validateContainer } from '../../util/dom';
import { observeStoreByKey } from '../../store';
import PRECOMPILED_CONVERSATIONAL_SEARCH_RESULT_TEMPLATE from './precompile-templates/conversationalsearchresult.handlebars';
import { registerHelper } from '../../util/handlebars';

export default class ConversationalSearchResult {
  constructor(client, reduxStore, conf) {
    this.client = client;
    this.conf = conf;
    this.reduxStore = reduxStore;

    registerHelper('markdown', function (text) {
      if (typeof text !== 'string') {
        return '';
      }

      return new handlebars.SafeString(marked(text));
    });

    if (validateContainer(conf.containerId)) {
      observeStoreByKey(this.reduxStore, 'search', () => this.render());
    }
  }

  render() {
    const currentSearchState = this.reduxStore.getState().search;
    const currentConversationalSearchResult = currentSearchState.conversationalSearchResult;
    const keyword = currentSearchState.keyword;

    const handlebarTemplateProps = {
      mainHeadlineText: this.conf.mainHeadlineText || 'Answer',
      subHeadlineText: keyword,
      answerText: currentConversationalSearchResult.answerText,
      sourcesHeadlineText: this.conf.sourcesHeadlineText || 'Sources:',
      sources: currentConversationalSearchResult.sources,
      aiExplanationText: this.conf.aiExplanationText || 'Generated by AI, may contain errors.'
    };

    // Compile HTML and inject to element if changed
    let html;

    // TODO loading state
    if (currentConversationalSearchResult.answerText) {
      if (this.conf.precompiledTemplate) {
        html = this.conf.precompiledTemplate(handlebarTemplateProps);
      } else if (this.conf.template) {
        html = handlebars.compile(this.conf.template)(handlebarTemplateProps);
      } else {
        html = PRECOMPILED_CONVERSATIONAL_SEARCH_RESULT_TEMPLATE(handlebarTemplateProps);
      }
    }

    console.log('currentSearchState', currentSearchState);

    if (this.renderedHtml === html) {
      return;
    }

    const container = document.getElementById(this.conf.containerId);
    container.innerHTML = html;
    this.renderedHtml = html;

    // Execute callback for when rendering is complete (if configured)
    if (
      this.conf.renderCompleteCallback &&
      typeof this.conf.renderCompleteCallback === 'function'
    ) {
      this.conf.renderCompleteCallback();
    }
  }
}
